Lo primero para hacer esta practica necesitamos instalar la libreria binaria de ZMQ. ZMQ es eso - libreria binaria que nos ofrece un cantidad de patrones de sockets. No es una framework etc. Una vez tenemos el paquete zmq binario instalado en nuestro sistema operativo, tenemos que instalar modulo de nodejs para que nuestros scrips de nodejs puedan 'hablar' con el zmq.
* Basico
** REQ - REP patron.
En este patron de comunicacion hemos complimentado los ejemplos ofrecidos /hwclient.js/, /hwserver.js/ con la posibilidad de pasarle los parametros ejecuntando los scripts en la linea de comandos. Asi que ejecuntado el cliente le pasamos la url del servidor, el numero de peticiones a enviar y el texto a enviar. Al servidor le pasamos el puerto, el cual usamos para hacer bind sobre todas las interfaces usando *el_socket_rep.bind('tcp://*puerto) sintaxis, y el texto de respuesta. El texto tanto en cliente como en el servidor puede ser un espacio en blanco o un texto de mas de 1 palabra con espacios entre ellos y sin englobarlos en las comillas. Usamos la tecnica short-circuit para asignar el espacio en blanco en caso de no pasar el ningun texto. /te = args[4] || ' ';/
** PUB - SUB
En este patron hay un publisher que hace bind y suscribers que hacen connect. En el subscriptor anadimos posibilidad de pasar por parametros la url de publisher y el descriptor de tipo de mensajes o los quieren suscribirse. En el publisher enviamos por argumentos puerto al que tendra que hacer el bind, numero de mensajes a publicar, descriptores de 2 tipos a publicar. El publisher publica la misma cantidad de mensajes de los tipos especificados y cada mensaje consiste en la concatenacion de tipo de descriptor de mensaje y un numero aleatorio. Los suscriptores se conectaran al publisher y ademas haran /subscribe(tipo_de_descriptor)/ para filtar mensajes que han indicado con el ultimo argumento.
** ROUTER - DEALER
En este caso nuestro cliente sigue usando el socket req, pero ahora se conecta y envia las peticiones al router y no directamente al servidor. El servidor, en este caso es el worker, sigue siendo el socket rep pero esta vez se conecta al broker. Asi que el broker inicia dos sockets, uno para que le envien los requests los clientes, y otro para conectarse al worker y enviarle las mismos requests recibidos por de clientes. Entonces, el socket de zmq /router/ es el que usa para conectarse con los clientes, ya que es un socket rep asincrono que el broker recibira los requests de los clientes. Para conectarse al worker, creara un socket de tipo /dealer/ ya que es un socket req asincrono y enviara por el los requests que el worker con su socket rep va a consumir. El cliente terminara cuando reciba la respuesta, mientras el broker y worker seguiran esperando ejecutandose. El zmq tiene un ventaja muy importante en el mercado de 'sockets' ya que el reparto lo hace de manera equitativa. Ya sea muchos clientes - pocos servidores, o muchos servidores - pocos clientes. En los dos caso el trabajo o las peticiones se repartiran de manera equitativa, nadie va a estar esperando mientras otros sean atendidos mas de una vez, ni tampoco estaran trabajando mas que otros (caso de servidores).

* Avanzado
El cliente aqui recibira 3 argumentos: url del router, su identidad, el mensaje. Enviara un mensaje al frontend del router, al que se conectara con un socket req pasandole la url. Como es obvio el socket req una vez envia un request se para y no hace nada mas hasta que no reciba las respuesta. En nuestro caso cuando reciba la respuesta, termineremos el script de cliente.

El worker recibira estos argumentos: url del backend del router, su identidad, texto diciendo que es disponible, texto de respuesta una vez haya acabado el trabajo, true/false para activar/desactivar el modo verbose. Esta vez el worker usara el socket req, asi que el router tendra dos sockets router (una para frontend y otra para el backend). El worker al iniciarse enviara un request para darse de alta. Tanto en script de worker como en el cliente usamos la propiedad /identity/ del socket para generar las identidades enviaremos encapsulados al broker y este las usara apropiadamente. En el cliente usamos un array para guardar la cantidad de  trabajos hechos por el worker, y lo vamos imprimiendo cada vez en casa de que le modo verbose este activo.

El broker crea 2 socket /router/ para recibir los requests asincronamente de los clientes y workers. Como el worker envia un request cuando se inicia, el broker capta ese mensaje por el backend. Cuando el worker req envia una request, el broker recibe ese request con el mensaje enviado + delimitador + identidad de worker (todo apilado). Entonces, en los mas alto de la 'pila' (pila = [].call.slice(arguments)) tenemos el string con la identidad del worker, luego un delimitador '', y luego el string 'ready' que indica al broker que le worker esta preparado para recibir el trabajo. Anadimos ese worker al nuestro array /workers/ como un objeto con dos propiedades (disp, jobs). Uno indica si es disponible o no (valores: ready/ocupado) y otro los trabajos que lleva hechos.
Ahora cuando recibimos un request de un cliente por el frontend, llamamos a la funcion buscaworker que mira hay un worker disponible para atender el request. En el caso de que alla, apilamos el mensaje recibido del cliente con el delimitador + identidad del worker que nos devolvio la function buscaworker. Ponemos la propiedad disp de este worker en nuestro array workers a 'ocupado'. Enviamos el nuevo mensaje constuido al worker para que haga el trabajo. Podemos enviarlo porque el worker hizo el primer request dandose de alta y ahora estara esperando el reply en su socket req. Si no hay worker disponible, entonces el mensaje del cliente lo apilamos a una array llamado cola.
Cuando el worker recibe el mensaje del cliente reenviado por el backend del broker pone un string 'ok' en el lugar del texto de mensaje del cliente y lo envia al broker. Ahora el broker, recibe un mensaje con un 'ok' y lo reenvia al cliente, quitandole la identidad del worker y el delimitador /args = args.slice(2);/, que estara esperando la respuesta el su socket req.
En los casos cuando el broker recibe un 'ready' o 'ok' del worker, siempre miramos si hay algun request en nuestro array cola. Si hay, le enviamos a ese worker un trabajo de la cola.
Hemos escrito nuestra function /showArguments/, /randnumber/ por eso no importamos el modulo auxfuntions.js
Asignamos a la propiedad de identidad de sockets de cliente y worker las identidades pasados por argumentos.
El script /script-worker.sh/ se usa asi *sh script-worker.sh <numero_de_workers> <numero_de_clientes> > output_del_fichero_donde_escribira_el_modo_verbose*. Hemos probado con 3 trabajadores y 10, 100, 200, 400, 800 workers. Una vez ejecutado el script los clientes acabando quedando proceso node de broker y n procesos de workers pasados por argumento. Hay un timer en worker que pasado el tiempo mata su proceso. Incluimos el fichero /output/ con la traza de 3 y 50 trabajadores.

* Experto
Aqui hemos mejorado las cosas hechas en el apartado avanzado con usando promesas, escribiendo algoritmos en la funcion buscaworker para escoger el worker usando load balancing, y un script lbconfig2.js que configura el broker dinamicamente.
En el cliente creamos la promesa usando la funcion propuesta por el enunciado: /makeSender(socket)(message).then(callback)/. Una de las ventajas de las promesas es que podemos asignar la function handler/callback despues que haya ocurrido el evento sobre el que estuvimos eschuchando. En el caso de la gestion de promesas del broker al worker: Tenemos que crear tantas promesas iniciales como workers. En el caso contrario cuando el worker hace un request no hay un evento de creado todavia en el broker para escuchar a ese request. En este caso de ejemplo 3. El worker es un socket req asi que nos hace peticiones a aqui al router del backend. Creando promesas aseguramos que cuando llegan las peticiones 'ready' del los workers, tengan asociado el handler. Pasamos un zero como para- metro porque no vamos a enviar nada, es un flag condicional. En el codigo se ve mejor lo hecho.
Aqui, cada trabajador con cada mensaje enviado, sea 'ok' o 'ready', enviara su carga que usara la funcion getload para eso. Apilamos un delimitador, y la carga calculada. Aunque en este caso no hace falta el delimitador, lo ponemos para asi mejor ver los mensajes que produce el modo verbose. Hay un temporador que hace que el broker envie mensajes nulos (lo representamos asi '') a los workers del array workers. En el worker recibimos ese mensaje nulo y enviamos como respuesta la carga precedida con un '' simbolizando mensaje nulo (tambien por el motivo de verbose). En el broker un vez recibimos los mensajes de los workers, extreamos la carga y la asignamos a cada worker como propiedad carga: /workers[args[0]].carga = args[6];/
El algoritmo usado para elegir el worker segun la carga se ve en la funcion /buscalow/.

En el broker creamos un socket de rep para recibir informacion del lbconfig2.js. Creamos asi /confpromesa(0).then(fconfig);/ una promesa que ejecuta fconfig funcion cuando el lbconfig2 nos envie su request. lbconfig2 usa un socket req, empaqueta los argumentos pasados, los pone en un objeto, lo pasa por el JSON.stringify() y envia al broker. El broker ejecuta fconfig que refleja en su codigo lo que hace. Si le ha pasado tipo de configuracion 'equitable' entonces, hace clearInterval al temporador que pide carga cada tanto. Despues de ejecutar lo adecuado a la peticion de lbconfig2 en la funcion fconfig acabamos con la instruccion /confpromesa('Cuando quieras puedes enviar otro!').then(fconfig);/ asi enviando al script de lbconfig2 su respuesta esperada (ya q es socket req y no avanza hasta que no reciba el reply) y al vez creando promesa para esperar a otro request de configuracion. En la busqueda de worker en el modo 'equitable' usamos el algoritmo en el cual usamos los jobs hechos por worker y los jobs hechos en total. Usamos la descviacion de media para decidir si cogemos al worker o no.
